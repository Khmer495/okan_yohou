// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.2 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/7xWbW8bRRD+K9bCx8Pvbpz7lroKqhClEhVClAhvfGP70L0se3ttrMiSzykltClIVOCm",
	"QTIqqZtQiQRU1DRN4ces74I/9S+g3T07ac6FAGrzwTe3tzPzPM/szGYZ1VybuA44zEP6MvJqTbCxNOcs",
	"oEwYhLoEKDNBLpuG+IUlbBMLkI6yufmZj+ZnPqzkK5Vi6cLFS+fKl96dn/+gOIc0xFpE7PEYNZ0GamvI",
	"cmuYma6TjGthmcwAr0ZNovagw8c74f4AaUf5CqX0mZkzs+VyQUN1l9rCC9UtF7OjdI5vLwJV6ZwpQX9b",
	"OxE0V5hNz5TK5eLs7D9Hbbc1xGBpCtpR5+5h/354/fPw5yfHwyMe3ODBDu+u8uD684Ng+PRG1LvPg53R",
	"xhYP1kbrt3jwIw8GPLjGuzfFtk437N7h3W+itYAHm8qRBw950JsEmaYuM5nId7w8L6bo82CLB7eib9d5",
	"sMqDwcviULPRAJosEqaEguclqUe7vfD7B3qqmqum3kqNHt5RC6lqXr537oZ7e6lqQbwMn32lPn7sCJEc",
	"30b65ZyW1woLGnJ8y8KLAjmjPkygmQ6DhippHcBiNklCGD67HV3rR7u9aG97DOT5QT+GIK1CbP23zLQp",
	"HBLMn/wR7g9eSUIG03gqhsfPVz6bLp6mG646hkeMKef23tao038lFK4uJdOFm9vRbm+cLlp/FKeLNr6I",
	"0402tlLVorIep6olZf2UgKAVtdIpYMg/DXlQ86nJWu+LGafO81nAVJ1zOfiE16JamkRpMkZU05tO3U2y",
	"kb19k3dvD/dXwx9+QZMunPLlClBPeeXSWSGPS8DBxEQ6KqSz6SzSEMGsKaFlsJi/0myAHDaiEeXwPG8g",
	"Hb0NbE7t0BAFj7iOpzjls1nxqLkOA0c6YkIsU83dzKeeGolq0MuBzsCWjm9SqCMdvZE5uhIy8X2QUZdB",
	"e6IKphS3lCwvyvHeO0hq7ds2pi2hQvceX9nmKwd8ZXW41/lz8CD8+rvw954IRlxvCrOLrnec2mc+eOys",
	"a7T+FatTkJHoT0iXSxa4QgEzMP6G1uH609Har3JDXLXMsnx+YhptFdACBkmm5+S64ip/zxvJahaTkC64",
	"qUosxMtRhZtfRhuPpMyYYhsYUA/pl5eRKUKIc4Y05GB56MdoY8FNCsa4mY4kPXFNtBc0RPxp9fNZktJr",
	"reL/lUxNC3plrJhPrXgS6JmM+BfGaroe08vZcha1F9p/BQAA//+OWaj2RQkAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

